from locust import HttpUser, task, between, events
from locust.clients import ResponseContextManager
import random
import string  
from loguru import logger  
import os
from itertools import count
import json
import gevent
import re
import time
from urllib.parse import unquote
import pandas as pd
from gevent.lock import Semaphore
from hashlib import sha256
import base64


data_dir = "/app/log"

counter = count(0)  # 计数器，用于生成唯一的消息 ID
answer_file = os.path.join(os.path.dirname(__file__), "answers.json")  # 日志文件路径
answers = {}
db_lock = Semaphore()


def calculate_bytes_sent(method: str, uri: str, request_headers: dict, body: str) -> int:
    """计算请求的字节数"""
    request_line = f"{method} {uri} HTTP/1.1\r\n"
    headers = "".join([f"{key}: {value}\r\n" for key, value in request_headers.items()])
    request = f"{request_line}{headers}\r\n{body}"
    return len(request)


def random_string(length: int = 15):  
    """生成随机字符串"""  
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))  


def new_log_entry(response: ResponseContextManager, extra: dict | None = None) -> dict:
    """创建新的日志条目""" 
    # print(str(response.request.body) if response.request.body else "")
    # print(response.request.headers)
    if type(response.request.body) == bytes:
        response.request.body = response.request.body.decode()
    try:
        body = json.loads(str(response.request.body)) if response.request.body else {} 
        body = {k: str(v) for k, v in body.items()}  # 将所有值转换为字符串
    except json.JSONDecodeError:
        boundary_match = re.search(r'boundary=(.+?)', response.request.headers.get('Content-Type', ''))
        body = {}
        if boundary_match:
            boundary = boundary_match.group(1)
            # print("boundary:", boundary)
            parts = response.request.body.decode("utf-8").split('--' + boundary)
            for part in parts:
                if 'Content-Disposition' in part:
                    # 提取 name
                    name_match = re.search(r'name="([^"]+)"', part)
                    if name_match:
                        name = name_match.group(1)
                        # print("name:", name)
                        if name == 'm1_files[]':
                            # 提取 filename
                            filename_match = re.search(r'filename="([^"]+)"', part)
                            if filename_match:
                                body['filename'] = filename_match.group(1)
                        else:
                            # 提取对应的值
                            # print(repr(part.split(name)[1]))
                            value_match = re.search(r'\r\n\r\n(.*?)\r\n', part.split(name)[1], re.DOTALL)
                            if value_match:
                                value = value_match.group(1).strip()
                                body[name] = value

    if response.request.headers.get("Content-Type") == "application/x-www-form-urlencoded":
        # 如果是表单提交，解析表单数据
        body = {unquote(k): unquote(v) for k, v in (item.split('=') for item in str(response.request.body).split('&'))}

    if extra:
        for key, value in extra.items():
            body[key] = str(value)  # 将所有值转换为字符串
    if '?' in response.request_meta["name"]:
        query_string = response.request_meta["name"].split('?')[1]
        query_params = query_string.split('&')
        for param in query_params:
            key, value = param.split('=')
            # 对key和value进行URL解码
            key = unquote(key)
            value = unquote(value)
            body[key] = value
    return {
        "verb": response.request_meta["request_type"],
        "uri": response.request_meta["name"],
        "bytes_sent": calculate_bytes_sent(
            response.request_meta["request_type"],
            response.request_meta["name"],
            response.request.headers,
            str(response.request.body) if response.request.body else "",
        ),
        "num_params": len(body),
        "params": body,
    }

class APIUser(HttpUser):  
    """定义用户行为"""  
    wait_time = between(2, 4)  # 每次请求之间的等待时间（1到3秒之间随机）
    
    # @task
    def create_user(self):
        email = f"{random_string()}@example.com"
        passwd = random_string(10)
        user = {
            "email": email,
            "password": passwd
        }
        x_request_id = str(next(counter))
        with self.client.post(
            url="/api/create_user/",
            json=user,
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response)
            if response.status_code == 200:
                db_statements = [
                    {
                        "type": "INSERT",
                        "table": "users",
                        "columns": {
                            "id": "*",
                            "email": email,
                            "hashed_password": sha256(passwd.encode()).hexdigest(),
                            "is_active": "t"
                        },
                        "is_match": True
                    }
                ]
                answers[x_request_id] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": time.time(),
                }
                response.success()
                return email
            else:
                response.failure(f"Failed to create user: {response.text}")
                return None

    # @task
    def get_users(self, skip=0, limit=1000000):
        # x_request_id = str(next(counter))
        with self.client.get(
            url=f"/api/get_users?skip={skip}&limit={limit}",
            catch_response=True,
        ) as response:
            if response.status_code == 200:
                response.success()
                df = pd.DataFrame(response.json())
                if df.empty:
                    return []
                ids = df["id"].to_list()
                emails = df["email"].to_list()
                return list(zip(ids, emails))
            else:
                response.failure(f"Failed to get users: {response.text}")
                return None

    # @task
    def update_user_password(self):
        with db_lock:
            email = self.create_user()
            # gevent.sleep(2)
            if email is None:
                logger.error("Fail to create user")
                return
            new_password = random_string(10)
            x_request_id = str(next(counter))
            with self.client.put(
                url=f"/api/update_user_password",
                params={
                    "email": email,
                    "new_password": new_password
                },
                headers={"x_request_id": x_request_id},
                catch_response=True,
            ) as response:
                entry = new_log_entry(response)
                if response.status_code == 200:
                    answers[x_request_id] = {
                        "http_request": entry,
                        "db_statements": [
                            {
                                "type": "UPDATE",
                                "table": "users",
                                "columns": {
                                    "hashed_password": sha256(new_password.encode()).hexdigest(),
                                    "id": "*"
                                },
                                "is_match": True
                            },
                        ],
                        "request_time": time.time(),
                    }
                    response.success()
                else:
                    response.failure(f"Failed to update password: {response.text}")

    # @task
    def delete_user_by_email(self):
        with db_lock:
            emails = self.get_users()
            if not emails:
                logger.debug("No record to delete")
                return
            user_id, email = random.choice(emails)
            x_request_id = str(next(counter))
            with self.client.delete(
                url=f"/api/delete_user_by_email",
                params={
                    "email": email
                },
                headers={"x_request_id": x_request_id},
                catch_response=True,
            ) as response:
    
                entry = new_log_entry(response)
                if response.status_code == 200:
                    answers[x_request_id] = {
                        "http_request": entry,
                        "db_statements": [
                            {
                                "type": "DELETE",
                                "table": "users",
                                "columns": {
                                    "id": user_id
                                },
                                "is_match": True
                            }
                        ],
                        "request_time": time.time(),
                    }
                    response.success()
                else:
                    response.failure(f"Failed to delete user by email: {response.text}")

    # @task
    def delete_user_by_id(self):
        with db_lock:
            user_ids = self.get_users()
            if not user_ids:
                logger.debug("No record to delete")
                return
            user_id, _ = random.choice(user_ids)
            x_request_id = str(next(counter))
            with self.client.delete(
                url=f"/api/delete_user_by_id",
                params={
                    "user_id": user_id
                },
                headers={"x_request_id": x_request_id},
                catch_response=True,
            ) as response:
    
                entry = new_log_entry(response)
                if response.status_code == 200:
                    answers[x_request_id] = {
                        "http_request": entry,
                        "db_statements": [
                            {
                                "type": "DELETE",
                                "table": "users",
                                "columns": {
                                    "id": user_id
                                },
                                "is_match": True
                            }
                        ],
                        "request_time": time.time(),
                    }
                    response.success()
                else:
                    response.failure(f"Failed to delete user by id: {response.text}")

    # @task
    def write_logfile(self):
        message = random_string(100)
        name = random_string(10)
        x_request_id = str(next(counter))
        with self.client.post(
            url="/api/write_logfile/",
            json={
                "message": message,
                "name": name
            },
            headers={"x_request_id": x_request_id},
            catch_response=True
        ) as response:
            entry = new_log_entry(response)
            if response.status_code == 200:
                name_ = base64.b64encode(name.encode()).decode()[:32]
                fs_operations = [
                    {
                        "operation": "create",
                        "source_path": f"{data_dir}/app_{name_}_{name}.log",
                        "destination_path": None,
                        "is_directory": False
                    },
                    {
                        "operation": "update",
                        "source_path": f"{data_dir}/app_{name_}_{name}.log",
                        "destination_path": None,
                        "is_directory": False
                    },
                ]
                answers[x_request_id] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time()
                }
                response.success()
            else:
                response.failure(f"Failed to write logfile: {response.text}")

    @task
    def execute_command(self):
        x_request_id = str(next(counter))
        name = "attack_" + random_string(10)
        content = random_string(150)
        command = f"echo '{content}' >> ./log/{name}.txt"
        with self.client.post(
            url="/api/execute_command/",
            json={"command": command},
            headers={"x_request_id": x_request_id},
            catch_response=True
        ) as response:
            entry = new_log_entry(response)
            if response.status_code == 200:
                fs_operations = [
                    {
                        "operation": "create",
                        "source_path": f"{data_dir}/{name}.txt",
                        "destination_path": None,
                        "is_directory": False
                    },
                    {
                        "operation": "update",
                        "source_path": f"{data_dir}/{name}.txt",
                        "destination_path": None,
                        "is_directory": False
                    }
                ]
                answers[x_request_id] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time()
                }
                response.success()
            else:
                response.failure(f"Failed to execute command: {response.text}")


    # @task
    # def write_logfile_line(self):
    #     x_request_id = str(next(counter))
    #     line_number = random.randint(1, 10)
    #     message = random_string(25)
    #     with self.client.put(
    #         url=f"/api/write_logfile/{line_number}",
    #         json=message,
    #         headers={"x_request_id": x_request_id},
    #         catch_response=True
    #     ) as response:
    #         entry = new_log_entry(response)
    #         if response.status_code == 200:
    #             answers[x_request_id] = {
    #                 "http_request": entry,
    #                 "request_time": time.time()
    #             }
    #             response.success()
    #         else:
    #             response.failure(f"Failed to write logfile line: {response.text}")

    
@events.test_stop.add_listener
def on_test_stop(environment, **_kwargs):
    # 将答案写入文件
    with open(answer_file, "w") as f:
        json.dump(answers, f, indent=4)
    logger.info(f"Answers written to {answer_file}")