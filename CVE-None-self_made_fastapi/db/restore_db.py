import pandas as pd
import subprocess
import re

from config import database_name, database_user, database_container


match_data = pd.read_json("matched_data.jsonl", lines=True, dtype={"request_id": str})


def get_earliest_attack_time(bad_requests):
    for _, row in match_data.iterrows():
        if row["request_id"] in bad_requests:
            print(f"恶意请求: {row['request_id']}")
            return row["evt.datetime"]
    return None


def generate_sql_file(latest_backup_time, bad_requests):
    if latest_backup_time is not None:
        sql_data = match_data[match_data["evt.datetime"] > latest_backup_time]
    with open("restore.sql", "w") as sql_file:
        for index, row in sql_data.iterrows():
            # 过滤掉恶意请求
            if row["request_id"] in bad_requests:
                continue
            sql = re.sub("\.(?=\s|$)", '', row["statement"])
            sql += ";"
            # if sql.startswith("SELECT") or sql.startswith("SHOW") or sql.startswith("DESCRIBE") or sql.startswith("SET"):
            #     continue
            sql_file.write(f"{sql}\n")
            # print(f"SQL语句: {sql}")
    print("SQL文件生成完毕")


def restore_db(bad_requests):
    attack_time = get_earliest_attack_time(bad_requests)
    if attack_time is None:
        print("没有受攻击影响的数据库操作")
        return
    print("攻击时间:", attack_time)
    # 先在 ./db_backup 找到最新的未受攻击影响备份文件
    result = subprocess.run(
        ["docker", "exec", database_container, "ls", "/db_backup"],
        capture_output=True,
        text=True,
        check=True,
    )
    backup_files = result.stdout.splitlines()
    backup_files = [f.replace("_", " ") for f in backup_files if f.endswith(".backup")]
    backup_files.sort()
    latest_clear_backup = None
    latest_clear_backup_time = None
    for backup_file in backup_files:
        if backup_file <= attack_time:
            latest_clear_backup = backup_file
            latest_clear_backup_time = backup_file.split(".backup")[0]
        else:
            break
    if latest_clear_backup is None:
        print("没有找到最新的干净备份文件")
        return

    print("最新干净备份文件:", latest_clear_backup)
    # latest_clear_backup_time = latest_clear_backup_time.replace(" ", "_")
    latest_clear_backup = latest_clear_backup.replace(" ", "_")
    # 复制出来
    # subprocess.run(
    #     ["docker", "cp", f"{database_container}:/db_backup/{latest_clear_backup}", "./"],
    #     check=True
    # )
    print("最新干净备份时间:", latest_clear_backup_time)
    
    generate_sql_file(latest_clear_backup_time, bad_requests)

    subprocess.run(["docker", "cp", "./restore.sql", f"{database_container}:/tmp/restore.sql"], check=True)
    if latest_clear_backup:
        # 恢复到最新干净备份
        subprocess.run(["docker", "exec", database_container, "pg_restore", "-U", database_user, "-d", database_name, "-c", f"/db_backup/{latest_clear_backup}"], check=True)
        print("数据库恢复到最新干净备份")
    else:
        # 清空数据库
        pass
        # subprocess.run(["docker", "exec", database_container, "psql", "-U", database_user, "-d", database_name, "-c", "DROP SCHEMA public CASCADE;"], check=True)

    subprocess.run(["docker", "exec", database_container, "psql", "-U", database_user, "-d", database_name, "-f", "/tmp/restore.sql"], check=True)
    # 执行SQL文件
    print("SQL文件执行完毕")


if __name__ == "__main__":
    import time
    times = []
    for i in range(10):
        st_time = time.time()
        restore_db(["17-314"])
        et_time = time.time()
        # print(f"恢复数据库操作耗时: {((et_time - st_time) * 1000):.3f} ms")
        times.append((et_time - st_time) * 1000)
    
    print(times)
    print(f"平均恢复数据库操作耗时: {sum(times) / len(times):.3f} ms")
    print("数据库恢复操作完成")
