import networkx as nx
from networkx.drawing.nx_agraph import to_agraph
import os
from enum import Enum


class ProcNode:
    def __init__(self, pid, name):
        self.pid = pid
        self.name = name
    
    def __str__(self):
        return f"{self.name}\nPID {self.pid}"

    def __repr__(self):
        return f"[Process {self.name} with PID {self.pid}]"

    def __hash__(self):
        return hash((self.pid, self.name))

    def __eq__(self, other):
        if isinstance(other, ProcNode):
            return self.pid == other.pid and self.name == other.name
        return False


class FileNode:
    def __init__(self, name, is_dir=False):
        self.is_dir = is_dir
        self.name = name
    
    def __str__(self):
        return f"{self.name}"

    def __repr__(self):
        return f"[File {self.name}]"
    
    def __hash__(self):
        return hash(self.name)
    
    def __eq__(self, other):
        if isinstance(other, FileNode):
            return self.name == other.name and self.is_dir == other.is_dir
        return False


class RequestNode:
    def __init__(self, request_id):
        self.request_id = request_id
    
    def __str__(self):
        return f"Request\nRID {self.request_id}"
    
    def __repr__(self):
        return f"[Request {self.request_id}]"
    
    def __hash__(self):
        return hash(self.request_id)
    
    def __eq__(self, other):
        if isinstance(other, RequestNode):
            return self.request_id == other.request_id
        return False


class EventEdge:
    def __init__(self, evt_type, evt_time, evt_buffer=None):
        self.evt_type = evt_type
        self.evt_time = evt_time
        self.evt_buffer = evt_buffer
    
    def __str__(self):
        return f"{self.evt_type}"
    
    def __repr__(self):
        return f"[Event {self.evt_type} at {self.evt_time}]"


class EdgeType(Enum):  
    # 文件读取操作  
    READ = "read"  
    
    # 文件写入操作  
    WRITE = "write"  
    
    # 文件复制相关操作  
    COPY_FROM = "copy_from"  
    COPY_TO = "copy_to"  
    COPY = "copy"  
    
    # 文件创建操作  
    CREATE = "create"  
    
    # 文件删除操作  
    DELETE = "delete"  

    CHMOD = "chmod"  # 文件权限修改操作
    CHOWN = "chown"  # 文件所有权修改操作
    
    # 目录操作  
    MKDIR = "mkdir"  
    RMDIR = "rmdir"  
    
    # 文件重命名操作  
    RENAME_TARGET = "rename_target"  
    RENAME = "rename"  
    
    # 进程创建操作  
    CREATE_SUBPROCESS = "create_subprocess"  


class ProvGraph:
    def __init__(self):
        # self.graph = nx.DiGraph()
        self.graph = nx.MultiDiGraph()
    
    def add_node(self, node):
        self.graph.add_node(node)

    def add_event_edge(self, src, dst, evt_type, evt_time, evt_buffer=None):
        self.graph.add_edge(src, dst, edge_obj=EventEdge(evt_type, evt_time, evt_buffer))
    
    def find_affected_files(self, start_node):
        affected_files = {}

        def add_affected_files(file_name, affect_type, affect_time, buffer=None):
            if file_name == "/dev/null":
                # 如果是/dev/null文件，则不记录
                return
            # if file_name in affected_files:
            #     if affect_time > affected_files[file_name]["time"]:
            #         return
            if file_name not in affected_files:
                # 如果文件不存在，则添加
                affected_files[file_name] = []
            # affected_files[file_name] = {"type": affect_type, "time": affect_time, "buffer": buffer}
            affected_files[file_name].append({"type": affect_type, "time": affect_time, "buffer": buffer})
            # 按照time排序
            affected_files[file_name] = sorted(affected_files[file_name], key=lambda x: x["time"])

        # 使用深度优先搜索遍历图
        # for src, dst in nx.edge_dfs(self.graph, source=start_node):
        #     edge_data = self.graph.get_edge_data(src, dst)
        #     edge_obj = edge_data.get("edge_obj")
        for src, dst, key in nx.edge_dfs(self.graph, source=start_node):  
            # 对于MultiDiGraph，需要使用边的键获取边数据  
            edge_data = self.graph.get_edge_data(src, dst, key)  
            edge_obj = edge_data.get("edge_obj") 
            if edge_obj and edge_obj.evt_type == EdgeType.WRITE:
                # 如果是写操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_affected_files(dst.name, "modify", edge_obj.evt_time, edge_obj.evt_buffer)
            elif edge_obj and edge_obj.evt_type == EdgeType.COPY_TO:
                # 如果是复制操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_affected_files(dst.name, "create", edge_obj.evt_time)
            elif edge_obj and edge_obj.evt_type == EdgeType.DELETE:
                # 如果是删除操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_affected_files(dst.name, "remove", edge_obj.evt_time)
            elif edge_obj and edge_obj.evt_type == EdgeType.RENAME_TARGET:
                # 如果是重命名操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_affected_files(dst.name, "create", edge_obj.evt_time)
                    # 找dst的另一个父节点，即重命名前的文件节点
                    for parent in self.graph.predecessors(dst):
                        if isinstance(parent, FileNode) and self.graph.get_edge_data(parent, dst)[0]["edge_obj"].evt_type == EdgeType.RENAME:
                            add_affected_files(parent.name, "remove", edge_obj.evt_time)
            elif edge_obj and edge_obj.evt_type == EdgeType.CREATE:
                # 如果是创建操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_affected_files(dst.name, "create", edge_obj.evt_time)
            elif edge_obj and edge_obj.evt_type == EdgeType.MKDIR:
                # 如果是创建目录操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_affected_files(dst.name, "create", edge_obj.evt_time)
            elif edge_obj and edge_obj.evt_type == EdgeType.RMDIR:
                # 如果是删除目录操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_affected_files(dst.name, "remove", edge_obj.evt_time)

        return affected_files

    def find_related_files(self, start_node):
        related_files = []

        def add_related_files(file_src, file_dst, affect_type, is_dir):
            related_files.append({
                "operation": affect_type,
                "source_path": file_src,
                "destination_path": file_dst,
                "is_directory": is_dir
            })

        # 使用深度优先搜索遍历图
        for src, dst, key in nx.edge_dfs(self.graph, source=start_node):  
            # 对于MultiDiGraph，需要使用边的键获取边数据  
            edge_data = self.graph.get_edge_data(src, dst, key)  
            edge_obj = edge_data.get("edge_obj") 
            if edge_obj and (edge_obj.evt_type == EdgeType.WRITE or edge_obj.evt_type == EdgeType.CHMOD or edge_obj.evt_type == EdgeType.CHOWN):
                # 如果是写操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_related_files(dst.name, None, "update", dst.is_dir)
            elif edge_obj and edge_obj.evt_type == EdgeType.COPY_TO:
                # 如果是复制操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    # 找dst的另一个父节点，即复制前的文件节点
                    for parent in self.graph.predecessors(dst):
                        if isinstance(parent, FileNode) and self.graph.get_edge_data(parent, dst)["edge_obj"].evt_type == EdgeType.COPY:
                            add_related_files(parent.name, dst.name, "copy", parent.is_dir)
            elif edge_obj and edge_obj.evt_type == EdgeType.DELETE:
                # 如果是删除操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_related_files(dst.name, None, "delete", dst.is_dir)
            elif edge_obj and edge_obj.evt_type == EdgeType.RENAME_TARGET:
                # 如果是重命名操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    # add_related_files(dst.name, "create", edge_obj.evt_time)
                    # 找dst的另一个父节点，即重命名前的文件节点
                    for parent in self.graph.predecessors(dst):
                        if isinstance(parent, FileNode) and self.graph.get_edge_data(parent, dst)[0]["edge_obj"].evt_type == EdgeType.RENAME:
                            add_related_files(parent.name, dst.name, "move", parent.is_dir)
            elif edge_obj and edge_obj.evt_type == EdgeType.CREATE:
                # 如果是创建操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_related_files(dst.name, None, "create", dst.is_dir)
            elif edge_obj and edge_obj.evt_type == EdgeType.MKDIR:
                # 如果是创建目录操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_related_files(dst.name, None, "create", dst.is_dir)
            elif edge_obj and edge_obj.evt_type == EdgeType.RMDIR:
                # 如果是删除目录操作并且目标节点是文件节点，则记录
                if isinstance(dst, FileNode):
                    add_related_files(dst.name, None, "delete", dst.is_dir)

        # 遍历图中的所有边，找read操作
        # for src, dst, key in self.graph.edges(keys=True):  
        #     edge_data = self.graph.get_edge_data(src, dst, key)  
        #     edge_obj = edge_data.get("edge_obj")  
        #     if edge_obj and edge_obj.evt_type == EdgeType.READ:  
        #     # 如果是读取操作并且目标节点是文件节点，则记录  
        #         if isinstance(src, FileNode):  
        #             add_related_files(src.name, None, "read", src.is_dir)

        return related_files

    # def find_read_files(self, start_node):
    #     read_files = set()

    #     # 遍历整个图的所有边
    #     for src, dst, edge_data in self.graph.edges(data=True):
    #         edge_obj = edge_data.get("edge_obj")
    #         if edge_obj and edge_obj.evt_type == "read":
    #             # 如果目标节点是 start_node 或其后续节点，则记录源节点
    #             if dst == start_node or nx.has_path(self.graph, start_node, dst):
    #                 if isinstance(src, FileNode):
    #                     read_files.add(src)

    #     return list(read_files)

    def draw_graph(self, save_path="/tmp/prov_graph/", file_format="png", show=True, file_name="prov_graph"):
        if not save_path.endswith("/"):
            save_path += "/"
        # print(f"Saving graph to {save_path}{file_name}.{file_format}")
        os.makedirs(save_path, exist_ok=True)

        # 定义节点属性
        node_attributes = {}
        for node in self.graph.nodes:
            node_type = type(node).__name__
            if node_type == "ProcNode":
                node_attributes[node] = {"shape": "rectangle", "style": "filled", "fillcolor": "skyblue"}
            elif node_type == "FileNode":
                node_attributes[node] = {"shape": "ellipse", "style": "filled", "fillcolor": "lightgreen"}

        # 将节点属性更新到图上
        nx.set_node_attributes(self.graph, node_attributes)

        # 定义边属性（可选）
        # edge_labels = {(u, v): str(d['edge_obj']) for u, v, d in self.graph.edges(data=True)}
        edge_labels = {}  
        for u, v, key, data in self.graph.edges(keys=True, data=True):  
            # 使用 (u, v, key) 作为边的唯一标识  
            edge_labels[(u, v, key)] = str(data.get('edge_obj', ''))  
        nx.set_edge_attributes(self.graph, edge_labels, "label")

        # 绘图
        graph_dot = to_agraph(self.graph)
        graph_dot.layout("dot")
        graph_dot.draw(f"{save_path}{file_name}.{file_format}", format=file_format, prog="dot")
        if show:
            # 用系统默认的图片查看器打开图片
            os.system(f"open {save_path}{file_name}.{file_format}")


if __name__ == "__main__":
    prov_graph = ProvGraph()
    prov_graph.add_event_edge(ProcNode(1, "proc1"), FileNode("file1"), "open", "2021-09-01 00:00:00")
    prov_graph.add_event_edge(ProcNode(1, "proc1"), FileNode("file2"), "open", "2021-09-01 00:00:00")
    prov_graph.draw_graph()