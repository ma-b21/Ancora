import json
import os
import pandas as pd

from config import hook_containers, DATA_DIRS, backup_dir_map, volume_map


fs_dict = json.load(
    open(f"./fs_results.json", "r"),
)
write_logs = pd.read_csv(
    f"./hook/log/{hook_containers[0]}.log",
    # 列名为 file, file_pos, buffer
    names=["time", "file", "file_pos", "buffer"],
)


def is_in_data_dirs(file):
    for data_dir in DATA_DIRS:
        if file.startswith(data_dir):
            return data_dir
    return None


def delete_affected_file(file):
    data_dir = is_in_data_dirs(file)
    # print(file)
    # print(data_dir, volume_map[data_dir] if data_dir else "No data dir")
    if data_dir:
        # 删除文件
        # print(file[len(data_dir):])
        file_path = os.path.join(volume_map[data_dir], file[len(data_dir):])
        # print(file_path)
        if os.path.exists(file_path):
            if os.path.isdir(file_path):
                # os.rmdir(file_path)
                os.system(f"sudo rm -rf {file_path}")
                # os.remove(file_path)
            print(f"Deleted affected file or directory: {file_path}")
        else:
            print(f"File not found: {file_path}")
    else:
        os.system(f"docker exec {hook_containers[0]} rm -f {file}")


def restore_file(file: str, attack_time: str, write_log: pd.DataFrame):
    # print(write_log[write_log["malicious"] == True])
    data_dir = is_in_data_dirs(file)
    if not data_dir:
        print(f"File {file} is not in data dirs, Copy from initial image")
        return
    
    backup_dir = backup_dir_map[data_dir]
    backups = os.listdir(backup_dir)
    backups.sort()
    clear_backup_time = None
    for backup in backups:
        if backup > attack_time:
            break
        clear_backup_time = backup

    clear_file = file.replace(data_dir, f"{backup_dir}{clear_backup_time}/")
    if write_log is not None:
        write_log = write_log[write_log["time"] > clear_backup_time]

    # 先将文件恢复到干净备份
    file_path = os.path.join(volume_map[data_dir], file[len(data_dir):])
    # if not os.path.exists(file_path):
    #     return
    if os.path.exists(clear_file):
        if os.path.exists(file_path):
            # 如果文件已经存在，则删除
            if os.path.isdir(file_path):
            #     os.rmdir(file_path)
            # else:
            #     os.remove(file_path)
                os.system(f"sudo rm -rf {file_path}")
        if os.path.isdir(clear_file):
            os.system(f"sudo cp -r '{clear_file}' '{file_path}'")
        else:
            os.system(f"sudo cp '{clear_file}' '{file_path}'")
        print(file)
        print(f"Restored file: {file_path} from {clear_file}")
    else:
        print(f"Clear File not found: {clear_file}")
        return

    # 恢复写日志
    if write_log is not None:
        def check_offset_range_occupied(fd, file_pos, buffer_length):  
            """  
            检查指定文件偏移范围是否已经有内容
            """  
            try:  
                # 尝试读取指定范围的内容  
                os.lseek(fd, file_pos, os.SEEK_SET)  
                existing_content = os.read(fd, buffer_length)  
                
                # 检查读取的内容是否全是空白或空字节  
                if all(b == 0 or b == ord(' ') for b in existing_content):
                    return None
                else:
                    return existing_content

            except Exception as e:  
                print(f"检查文件偏移范围时发生错误: {e}")  
                return None
        fd = os.open(file_path, os.O_RDWR)
        for _, row in write_log.iterrows():
            # 恢复写日志
            file_pos = row["file_pos"]
            buffer = bytes.fromhex(row["buffer"])
            buffer_length = len(buffer)

            # 如果是恶意操作，则替换为相同长度的空格
            if row["malicious"]:
                # 检查指定偏移范围是否已经有内容
                existing_content = check_offset_range_occupied(fd, file_pos, buffer_length)
                if existing_content is not None:
                    print(f"Offset {file_pos} already occupied, existing content: {existing_content}")
                buffer = b" " * (len(buffer) - 1) + b"\n"
                print(f"Restored malicious write log: {file_path} at {file_pos}")
            
            # 手动调用pwrite系统调用，在指定偏移量写入buffer
            os.pwrite(
                fd,
                buffer,
                int(file_pos),
            )
            print(f"Restored write log: {file_path} at {file_pos}")
        os.close(fd)


def restore_fs(malicious_requests):
    affected_files = []
    for request in malicious_requests:
        for file, datas in fs_dict[request].items():
            for data in datas:
                if data["type"] == "create":
                    delete_affected_file(file)
                    break
                affected_files.append(
                    {
                        "file": file,
                        "type": data["type"],
                        "time": data["time"]
                    }
                )
    if not affected_files:
        print("No affected files")
        return
    affected_files = pd.DataFrame(affected_files)
    affected_files = affected_files.groupby("file", sort=False)
    write_log_files = write_logs.groupby("file", sort=False)

    for file, datas in affected_files:
        datas.sort_values("time", inplace=True)
        if file not in write_log_files.groups.keys():
            # 如果没有写日志，则直接恢复文件
            restore_file(
                file,
                datas.iloc[0]["time"],
                None,
            )
            continue
        write_log = write_log_files.get_group(file)
        write_log["malicious"] = False
        attack_time = datas.iloc[0]["time"]

        for _, attack_data in datas.iterrows():
            if attack_data["type"] == "remove":
                continue
            # 找到最近的且时间戳小于attack_data["time"]的行 
            filtered_rows = write_log[write_log["time"] < attack_data["time"]]
            if filtered_rows.empty:
                continue
            nearest_row = write_log[write_log["time"] < attack_data["time"]].iloc[-1]  
            # 将对应行的malicious标记为True  
            write_log.loc[nearest_row.name, "malicious"] = True
        
        restore_file(
            file,
            attack_time,
            write_log,
        )

            



if __name__ == "__main__":
    import time
    import random
    all_keys = list(fs_dict.keys())
    malicious_num = 80
    times = []
    for i in range(10):
        malicious_requests = random.sample(all_keys, malicious_num)
        all_keys = [key for key in all_keys if key not in malicious_requests]
        print(f"Malicious requests: {malicious_requests}")
        start_time = time.time()
        restore_fs(malicious_requests)
        end_time = time.time()
        print(f"恢复时间: {(end_time - start_time) * 1000} ms")
        times.append(end_time - start_time)
    
    print(f"平均恢复时间: {sum(times) / len(times) * 1000} ms")